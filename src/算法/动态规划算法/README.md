#1） 动态规划为什么会快？
因为这里不需要调用函数计算重复子问题，那么一定就是快很多么？
不一定，这取决于重复子问题的多少。0/1背包问题当数据量大时，
他的时间节省比较多的原因在与我们设计的重复子问题比较好，
因为对于物品的多种组合来说，他们的剩余空间的一致的概率比较大，
多以告知重复子问题会比较多。

#2）动态规划的核心：
核心在于memory的设计，这里我们利用了memo[(len(oraSet),leftRoom)]
中的(len(oraSet),leftRoom)字典作为键，为什么可以利用len(oraSet)
而不是oraSet呢（当然oraSet也是可以的）？这是因为对于每一层的子节点来说，
剩余物品的个数都是一致的，这个个数可以区分重复子问题。
而动态规划相较于普通的递归算法，主要的就是增加了memory

#3）如何设计动态规划算法：
首先看问题是否满足动态规划的两个条件：重复子问题，最优子结构；
然后首先利用递归算法解决问题，设计memory，然后修改递归算法的实现，
加入memory，最终实现动态规划的算法。
